<?php
/**
 * @file
 */

include_once('pw_api.features.inc');

/**
 * Helper function used by hooks below for translating XML root elements.
 * 
 * Translates the root elements of the following API parts:
 * areacodes.xml:               taxonomy_term_datas -> areacodes, taxonomy_term_data -> areacode
 * constituencies.xml:          taxonomy_term_datas -> constituencies, taxonomy_term_data -> constituency
 * dialogues.xml:               nodes -> dialogues, node -> dialogue
 * parliaments.xml:             taxonomy_term_datas -> parliaments, taxonomy_term_data -> parliament
 * profile.xml || profiles.xml: user_revisions -> profiles, user_revision -> profile
 * 
 * This is hard-coded in here, because it is announced, that the root element
 * is changeable in the next version of the views export module. After the update,
 * this code will become obsolete.
 * 
 * @param String $input
 * @return String 
 */
function tag_replace($input) {
  // Get the current request path:
  $tmparr = explode("/", request_path());
  $count = count($tmparr);
  $requestname = "";
  if ($count != 0) {
    $requestname = str_replace(".xml", "", $tmparr[$count - 1]);
  }
  
  $replace_arr = array(); // IMPORTANT: The order within this array is crucial. Longer names have to be inserted _before_ shorter ones.
  switch ($requestname) {
    case "areacodes":
      $replace_arr = array("taxonomy_term_datas" => "areacodes", "taxonomy_term_data" => "areacode");
      break;
    case "constituencies":
      $replace_arr = array("taxonomy_term_datas" => "constituencies", "taxonomy_term_data" => "constituency");
      break;
    case "dialogues":
      $replace_arr = array("nodes" => "dialogues", "node" => "dialogue");
      break;
    case "parliaments":
      $replace_arr = array("taxonomy_term_datas" => "parliaments", "taxonomy_term_data" => "parliament");
      break;
    case "profile":
    case "profiles":
      $replace_arr = array("user_revisions" => "profiles", "user_revision" => "profile");
      break;
    default:
      // do nothing
      break;
  }
  
//  $replace_arr = variable_get('pw_api_replacement', array());
  if (array_key_exists($input, $replace_arr)) {
    return $replace_arr[$input];
  }
  return $input;
}

function pw_api_preprocess_views_data_export_xml_header(&$vars) {
  $vars['root_node'] = tag_replace($vars['root_node']);
}

function pw_api_preprocess_views_data_export_xml_footer(&$vars) {
  $vars['root_node'] = tag_replace($vars['root_node']);
}

/**
 * Preprocess xml output template.
 */
function pw_api_preprocess_views_data_export_xml_body(&$vars) {
  _views_data_export_header_shared_preprocess($vars);
  _views_data_export_body_shared_preprocess($vars);

  // Compute the tag name based on the views base table, minus any trailing 's'.
  $vars['item_node'] = _views_data_export_xml_tag_clean(rtrim($vars['view']->base_table, 's'));
  $vars['item_node'] = tag_replace($vars['item_node']);

  foreach ($vars['themed_rows'] as $num => $row) {
    foreach ($row as $field => $content) {
      // Prevent double encoding of the ampersand. Look for the entities produced by check_plain().
      $content = preg_replace('/&(?!(amp|quot|#039|lt|gt);)/', '&amp;', $content);

      
      // insert CDATA into dialogue fields:
      if ($field == "body" || $field == "comment_body" || $field == "field_dialogue_annotation_1") {
        $content = '<![CDATA['.str_replace(']]>', ']]]]><![CDATA[>', $content).']]>';
      }

      $vars['themed_rows'][$num][$field] = array(); // reset the array, otherwise strange things will happen
      if (substr_count($content, "||") > 0) { // Multiple-Feld
        $tmp_arr = explode("||", $content);
        if (substr_count($tmp_arr[0], "##") > 0) { // Multiple-Feld mit Attributen
          $collection_arr = array();
          foreach ($tmp_arr as $tmp) {
            $inner_tmp_arr = explode("##", $tmp);
            $collection_arr[] = array(
                "attribute_name" => $inner_tmp_arr[0],
                "attribute_value" => $inner_tmp_arr[1],
                "value" => $inner_tmp_arr[2]);
          }
          $vars['themed_rows'][$num][$field]["type"] = "multiplefield_with_attributes";
          $vars['themed_rows'][$num][$field]["content"] = $collection_arr;
        } else { // Multiple-Feld ohne Attribute
          $vars['themed_rows'][$num][$field]["type"] = "multiplefield_without_attributes";
          $vars['themed_rows'][$num][$field]["content"] = $tmp_arr;
        }
      } else if (substr_count($content, "##") > 0) { // Single field with attributes
        $inner_tmp_arr = explode("##", $content);
        $vars['themed_rows'][$num][$field]["type"] = "singlefield_with_attributes";
        $vars['themed_rows'][$num][$field]["content"] = array(
                "attribute_name" => $inner_tmp_arr[0],
                "attribute_value" => $inner_tmp_arr[1],
                "value" => $inner_tmp_arr[2]);
      } else if (substr_count($content, "}{") > 0) { // Single field with single subfields
        $tmp_arr = explode("}{", $content);
        $collection_arr = array();
        foreach ($tmp_arr as $tmp) {
          $inner_tmp_arr = explode("**", $tmp);
          $collection_arr[] = array(
                "name" => $inner_tmp_arr[0],
                "value" => $inner_tmp_arr[1]);
        }
        $vars['themed_rows'][$num][$field]["type"] = "singlefield_with_single_subfields";
        $vars['themed_rows'][$num][$field]["content"] = $collection_arr;
      } else {
        $vars['themed_rows'][$num][$field]["type"] = "singlefield_without_attributes";
        $vars['themed_rows'][$num][$field]["content"] = $content;
      }
      // Case 1: Multiple Field with additional attributes
      // example: a##b##c||d##e##f =>
      // <examples>
      //   <example a="b">c</bsp>
      //   <example d="e">f</bsp>
      // </examples>
      // 
      // Case 2: Multiple field without additional attributes
      // example: a||b =>
      // <examples>
      //   <example>a</bsp>
      //   <example>b</bsp>
      // </examples>
      // 
      // Case 3: Single field with single subfields
      // example: name1**val1}{name2**val2 =>
      // <example>
      //   <name1>val1</name1>
      //   <name2>val2</name1>
      // </example>
    }
  }

  foreach ($vars['header'] as $field => $header) {
    // If there is no field label, use 'no name'.
    $vars['xml_tag'][$field] = !empty($header) ? $header : 'no name';
    if ($vars['options']['transform']) {
      switch ($vars['options']['transform_type']) {
        case 'dash':
          $vars['xml_tag'][$field] = str_replace(' ', '-', $header);
          break;
        case 'underline':
          $vars['xml_tag'][$field] = str_replace(' ', '_', $header);
          break;
        case 'camel':
          $vars['xml_tag'][$field] = str_replace(' ', '', ucwords(strtolower($header)));
          // Convert the very first character of the string to lowercase.
          $vars['xml_tag'][$field][0] = strtolower($vars['xml_tag'][$field][0]);
          break;
        case 'pascal':
          $vars['xml_tag'][$field] = str_replace(' ', '', ucwords(strtolower($header)));
          break;
      }
    }
    // We should always try to output valid XML.
    $vars['xml_tag'][$field] = _views_data_export_xml_tag_clean($vars['xml_tag'][$field]);
    $vars['xml_tag'][$field] = tag_replace($vars['xml_tag'][$field]);
  }
}